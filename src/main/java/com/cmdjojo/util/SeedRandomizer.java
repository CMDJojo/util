package com.cmdjojo.util;

import java.util.Random;

/**
 * Generates random values by seed. Can also generate by seed and coordinates
 *
 * @author CMDJojo
 * @version 2.1-SNAPSHOT
 */

public class SeedRandomizer {
    private long seed;
    private long rawseed;
    private Random generator;
    private boolean secure;

    /**
     * Creates an instance of SeedRandomizer to create random numbers, using the provided seed
     *
     * @param seed The seed to be used for all randomization
     */
    public SeedRandomizer(long seed) {
        this(seed, false);
    }

    /**
     * Creates an instance of SeedRandomizer to create random numbers, using a random seed
     */
    public SeedRandomizer() {
        this(r(), false);
    }

    /**
     * Creates an instance of SeedRandomizer to create random numbers, using the provided seed
     *
     * @param seed   The seed to be used for all randomization
     * @param secure If true, this object won't allow seed reading, changes or resetting
     */
    public SeedRandomizer(long seed, boolean secure) {
        setSeed(seed);
        this.secure = secure;
    }

    /**
     * Creates an instance of SeedRandomizer to create random numbers, using a random seed
     *
     * @param secure If true, this object won't allow seed reading, changes or resetting
     */
    public SeedRandomizer(boolean secure) {
        this(r(), secure);
    }

    /**
     * Returns a random seed (a random long, if you will)
     *
     * @return a random seed (a random long, if you will)
     * @deprecated use randomLong()
     */
    @Deprecated
    public static long randomSeed() {
        return randomLong();
    }

    /**
     * Returns a random long, which can be used for a seed
     *
     * @return a random long
     */

    public static long randomLong() {
        return r();
    }

    private static long r() {
        Random r = new Random();
        return r.nextLong();
    }

    private static long r(long s) {
        Random r = new Random(s);
        return r.nextLong();
    }

    private static int ri(long s) {
        Random r = new Random(s);
        return r.nextInt();
    }

    private static double rd(long s) {
        Random r = new Random(s);
        return r.nextDouble();
    }

    private static long lbetween(long d, long max) {
        return lbetween(d, 0, max);
    }

    private static long longHash(byte[] a) {
        long hash = 0xcbf29ce484222325L;
        for (int i = 0; i < a.length; i++) {
            hash ^= (a[i] & 0xff);
            hash *= 1099511628211L;
        }
        return hash;
    }

    private static long lbetween(long d, long min, long max) {
        return (long) (rd(d) * (max - min) + min);
    }

    /**
     * Makes this randomizer "secure", not allowing seed changes, resets, or reading of seed
     * <p>
     * Be careful! This is an one-way action
     */

    public void makeSecure() {
        secure = true;
    }

    /**
     * Checks whenether this randomizer is secure or not
     *
     * @return true if secure, false if not
     */
    public boolean getSecure() {
        return secure;
    }

    /**
     * Gets the seed, only in non-secure randomizers
     * Does only work in non-secure randomizer object
     *
     * @return seed
     */

    public long getSeed() {
        if (secure) return 0;
        return this.rawseed;
    }

    /**
     * Sets the seed, and resets all non-value-based randomizations, for example nextLong(), nextInt()
     * Does only work in non-secure randomizer object
     *
     * @param seed The seed to set
     */
    public void setSeed(long seed) {
        if (secure) return;
        this.rawseed = seed;
        long tseed = seed;
        for (int i = 0; i < 10; i++) {
            byte[] a = new byte[8];
            for (int j = 0; j < 8; j++) {
                a[7 - j] = (byte) (tseed & 0xFF);
                tseed = tseed >>> 8;
            }
            tseed = longHash(a);
        }
        this.seed = tseed;
        reset();
    }

    /**
     * Resets the generator for all non-value-based randomizations, returning the same values as it did in the start.
     * Does only work in non-secure randomizer object
     * <p>
     * Be careful when using this for games, this can make patterns predictable!
     */
    public void reset() {
        if (secure) return;
        this.generator = new Random(seed);
    }

    /**
     * Returns the next long generated by the generator
     *
     * @return the next long generated by the generator
     */
    public long nextLong() {
        return generator.nextLong();
    }

    /**
     * Returns the next int generated by the generator
     *
     * @return the next int generated by the generator
     */
    public int nextInt() {
        return generator.nextInt();
    }

    /**
     * Returns the next double generated by the generator
     *
     * @return the next double generated by the generator
     */
    public double nextDouble() {
        return generator.nextDouble();
    }

    /**
     * Returns a int generated by the seed and the provided coordiantes
     * <p>
     * This is NOT generated by the generator.
     * Providing the same seed (when constructing or using setSeed()) and the same coordinates will return the same value.
     * You can have up to 4 coordinates when generating such an value.
     * <p>
     * This can be used for games where you can have coordinates with content that is seed-dependent.
     * It can also be used for games where you need random values, but want to be able to re-generate the same ones.
     *
     * @param coords any amount of coordinates
     * @return a random int generated by the seed and the coordinates. Same seed and same coordinates will return the same value
     */
    public long coordInt(long... coords) {
        long s = coordToLong(coords) ^ seed;
        return ri(s);
    }

    /**
     * Returns a long generated by the seed and the provided coordiantes
     * <p>
     * This is NOT generated by the generator.
     * Providing the same seed (when constructing or using setSeed()) and the same coordinates will return the same value.
     * You can have up to 4 coordinates when generating such an value.
     * <p>
     * This can be used for games where you can have coordinates with content that is seed-dependent.
     * It can also be used for games where you need random values, but want to be able to re-generate the same ones.
     *
     * @param coords any amount of coordinates
     * @return a random long generated by the seed and the coordinates. Same seed and same coordinates will return the same value
     */
    public long coordLong(long... coords) {
        long s = coordToLong(coords) ^ seed;
        return r(s);
    }

    /**
     * Returns a double generated by the seed and the provided coordiantes
     * <p>
     * This is NOT generated by the generator.
     * Providing the same seed (when constructing or using setSeed()) and the same coordinates will return the same value.
     * You can have up to 4 coordinates when generating such an value.
     * <p>
     * This can be used for games where you can have coordinates with content that is seed-dependent.
     * It can also be used for games where you need random values, but want to be able to re-generate the same ones.
     *
     * @param coords any amount of coordinates
     * @return a random double generated by the seed and the coordinates. Same seed and same coordinates will return the same value
     */

    public double coordDouble(long... coords) {
        long s = coordToLong(coords) ^ seed;
        return rd(s);
    }

    /**
     * Returns a long between the min (incl) and max (excl) values generated by the seed and the provided coordiantes
     * <p>
     * This is NOT generated by the generator.
     * Providing the same seed (when constructing or using setSeed()) and the same coordinates will return the same value.
     * You can have up to 4 coordinates when generating such an value.
     * <p>
     * This can be used for games where you can have coordinates with content that is seed-dependent.
     * It can also be used for games where you need random values, but want to be able to re-generate the same ones.
     *
     * @param min    the minimum value the method can return
     * @param max    the upper bound, the returned value cannot become this value
     * @param coords any amount of coordinates
     * @return a random long between min (incl) and max (excl) generated by the seed and the coordinates. Same seed and same values (coords/min/max) will return the same value
     */

    public long coordBetween(long min, long max, long... coords) {
        if (min < 0 || max < 0 || max < min)
            throw new IllegalArgumentException("min can't be higher than max, and both min and max must be non-negative");
        long s = coordToLong(coords) ^ seed;
        return lbetween(s, min, max);
    }

    private long coordToLong(long... coords) {
        byte[] a = new byte[coords.length * 8];
        for (int i = 0; i < coords.length; i++) {
            for (int j = 0; j < 8; j++) {
                a[a.length - 1 - (i * 8 + j)] = (byte) (coords[i] & 0xFF);
                coords[i] = coords[i] >>> 8;
            }
        }
        return longHash(a);
    }

    /**
     * Returns a random number between 0 (incl) and max (excl) generated by the generator
     *
     * @param max The upper bound (excl)
     * @return a random number between 0 (incl) and max (excl) generated by the generator using nextLong()
     */
    public long nextBetween(long max) {
        return lbetween(generator.nextLong(), max);
    }

    /**
     * Returns a random number between min (incl) and max (excl) generated by the generator
     *
     * @param min The minimum value (incl)
     * @param max The upper bound (excl)
     * @return a random number between min (incl) and max (excl) generated by the generator using nextLong()
     */
    public long nextBetween(long min, long max) {
        return lbetween(generator.nextLong(), min, max);
    }
}
