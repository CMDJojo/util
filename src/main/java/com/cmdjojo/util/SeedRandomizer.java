package com.cmdjojo.util;

import java.util.Random;

/**
 * Generates random values by seed. Can also generate by seed and coordinates
 *
 * @author CMDJojo
 * @version 1.0-SNAPSHOT
 */

public class SeedRandomizer {
    private long seed;
    private Random generator;
    private boolean secure = false;

    /**
     * Creates an instance of SeedRandomizer to create random numbers, using the provided seed
     *
     * @param seed The seed to be used for all randomization
     */
    SeedRandomizer(long seed) {
        setSeed(seed);
    }

    /**
     * Creates an instance of SeedRandomizer to create random numbers, using a random seed
     */
    SeedRandomizer() {
        setSeed(r());
    }

    /**
     * Creates an instance of SeedRandomizer to create random numbers, using the provided seed
     *
     * @param seed   The seed to be used for all randomization
     * @param secure If true, this object won't allow seed reading, changes or resetting
     */
    SeedRandomizer(long seed, boolean secure) {
        setSeed(seed);
        this.secure = secure;
    }

    /**
     * Creates an instance of SeedRandomizer to create random numbers, using a random seed
     *
     * @param secure If true, this object won't allow seed reading, changes or resetting
     */
    SeedRandomizer(boolean secure) {
        setSeed(r());
        this.secure = secure;
    }

    /**
     * Makes this randomizer "secure", not allowing seed changes, resets, or reading of seed
     * <p>
     * Be careful! This is an one-way action
     */

    public void makeSecure() {
        secure = true;
    }

    /**
     * Checks whenether this randomizer is secure or not
     *
     * @return true if secure, false if not
     */
    public boolean getSecure() {
        return secure;
    }

    /**
     * Gets the seed, only in non-secure randomizers
     * Does only work in non-secure randomizer object
     *
     * @return seed
     */

    public long getSeed() {
        if (secure) return 0;
        return this.seed;
    }

    /**
     * Sets the seed, and resets all non-value-based randomizations, for example nextLong(), nextInt()
     * Does only work in non-secure randomizer object
     *
     * @param seed The seed to set
     */
    public void setSeed(long seed) {
        if (secure) return;
        this.seed = seed;
        reset();
    }

    /**
     * Resets the generator for all non-value-based randomizations, returning the same values as it did in the start.
     * Does only work in non-secure randomizer object
     * <p>
     * Be careful when using this for games, this can make patterns predictable!
     */
    public void reset() {
        if (secure) return;
        this.generator = new Random(seed);
    }

    /**
     * Returns the next long generated by the generator
     *
     * @return the next long generated by the generator
     */
    public long nextLong() {
        return generator.nextLong();
    }

    /**
     * Returns the next int generated by the generator
     *
     * @return the next int generated by the generator
     */
    public int nextInt() {
        return generator.nextInt();
    }

    /**
     * Returns the next double generated by the generator
     *
     * @return the next double generated by the generator
     */
    public double nextDouble() {
        return generator.nextDouble();
    }

    /**
     * Returns a random number between 0 (incl) and max (excl) generated by the generator
     *
     * @param max The upper bound (excl)
     * @return a random number between 0 (incl) and max (excl) generated by the generator
     */
    public long nextBetween(long max) {
        return lbetween(generator.nextLong(), max);
    }

    /**
     * Returns a random number between min (incl) and max (excl) generated by the generator
     *
     * @param min The minimum value (incl)
     * @param max The upper bound (excl)
     * @return a random number between min (incl) and max (excl) generated by the generator
     */
    public long nextBetween(long min, long max) {
        return lbetween(generator.nextLong(), min, max);
    }

    /**
     * Returns a long generated by the seed and the provided coordiantes
     * <p>
     * This is NOT generated by the generator.
     * Providing the same seed (when constructing or using setSeed()) and the same coordinates will return the same value.
     * You can have up to 4 coordinates when generating such an value.
     * <p>
     * This can be used for games where you can have coordinates with content that is seed-dependent.
     * It can also be used for games where you need random values, but want to be able to re-generate the same ones.
     *
     * @param x x-coordinate
     * @param y y-coordinate
     * @return a random long generated by the seed and the coordinates. Same seed and same coordinates will return the same value
     */
    public long coordLong(int x, int y) {
        long s = coordToLong(x, y) ^ seed;
        return r(s);
    }

    /**
     * Returns a double generated by the seed and the provided coordiantes
     * <p>
     * This is NOT generated by the generator.
     * Providing the same seed (when constructing or using setSeed()) and the same coordinates will return the same value.
     * You can have up to 4 coordinates when generating such an value.
     * <p>
     * This can be used for games where you can have coordinates with content that is seed-dependent.
     * It can also be used for games where you need random values, but want to be able to re-generate the same ones.
     *
     * @param x x-coordinate
     * @param y y-coordinate
     * @return a random double generated by the seed and the coordinates. Same seed and same coordinates will return the same value
     */

    public double coordDouble(int x, int y) {
        long s = coordToLong(x, y) ^ seed;
        return rd(s);
    }

    /**
     * Returns a long between the min (incl) and max (excl) values generated by the seed and the provided coordiantes
     * <p>
     * This is NOT generated by the generator.
     * Providing the same seed (when constructing or using setSeed()) and the same coordinates will return the same value.
     * You can have up to 4 coordinates when generating such an value.
     * <p>
     * This can be used for games where you can have coordinates with content that is seed-dependent.
     * It can also be used for games where you need random values, but want to be able to re-generate the same ones.
     *
     * @param x   x-coordinate
     * @param y   y-coordinate
     * @param min the minimum value the method can return
     * @param max the upper bound, the returned value cannot become this value
     * @return a random long between min (incl) and max (excl) generated by the seed and the coordinates. Same seed and same values (coords/min/max) will return the same value
     */

    public long coordBetween(int x, int y, long min, long max) {
        if (min < 0 || max < 0 || max < min)
            throw new IllegalArgumentException("min can't be higher than max, and both min and max must be non-negative");
        long s = coordToLong(x, y) ^ seed;
        double d = rd(s);
        return lbetween(d, min, max);
    }

    /**
     * Returns a long generated by the seed and the provided coordiantes
     * <p>
     * This is NOT generated by the generator.
     * Providing the same seed (when constructing or using setSeed()) and the same coordinates will return the same value.
     * You can have up to 4 coordinates when generating such an value.
     * <p>
     * This can be used for games where you can have coordinates with content that is seed-dependent.
     * It can also be used for games where you need random values, but want to be able to re-generate the same ones.
     *
     * @param x x-coordinate
     * @param y y-coordinate
     * @param z z-coordinate
     * @return a random long generated by the seed and the coordinates. Same seed and same coordinates will return the same value
     */
    public long coordLong(int x, int y, int z) {
        long s = coordToLong(x, y, z) ^ seed;
        return r(s);
    }

    /**
     * Returns a double generated by the seed and the provided coordiantes
     * <p>
     * This is NOT generated by the generator.
     * Providing the same seed (when constructing or using setSeed()) and the same coordinates will return the same value.
     * You can have up to 4 coordinates when generating such an value.
     * <p>
     * This can be used for games where you can have coordinates with content that is seed-dependent.
     * It can also be used for games where you need random values, but want to be able to re-generate the same ones.
     *
     * @param x x-coordinate
     * @param y y-coordinate
     * @param z z-coordinate
     * @return a random double generated by the seed and the coordinates. Same seed and same coordinates will return the same value
     */

    public double coordDouble(int x, int y, int z) {
        long s = coordToLong(x, y, z) ^ seed;
        return rd(s);
    }

    /**
     * Returns a long between the min (incl) and max (excl) values generated by the seed and the provided coordiantes
     * <p>
     * This is NOT generated by the generator.
     * Providing the same seed (when constructing or using setSeed()) and the same coordinates will return the same value.
     * You can have up to 4 coordinates when generating such an value.
     * <p>
     * This can be used for games where you can have coordinates with content that is seed-dependent.
     * It can also be used for games where you need random values, but want to be able to re-generate the same ones.
     *
     * @param x   x-coordinate
     * @param y   y-coordinate
     * @param z   z-coordinate
     * @param min the minimum value the method can return
     * @param max the upper bound, the returned value cannot become this value
     * @return a random long between min (incl) and max (excl) generated by the seed and the coordinates. Same seed and same values (coords/min/max) will return the same value
     */

    public long coordBetween(int x, int y, int z, long min, long max) {
        if (min < 0 || max < 0 || max < min)
            throw new IllegalArgumentException("min can't be higher than max, and both min and max must be non-negative");
        long s = coordToLong(x, y, z) ^ seed;
        return lbetween(s, min, max);
    }

    /**
     * Returns a long generated by the seed and the provided coordiantes
     * <p>
     * This is NOT generated by the generator.
     * Providing the same seed (when constructing or using setSeed()) and the same coordinates will return the same value.
     * You can have up to 4 coordinates when generating such an value.
     * <p>
     * This can be used for games where you can have coordinates with content that is seed-dependent.
     * It can also be used for games where you need random values, but want to be able to re-generate the same ones.
     *
     * @param x x-coordinate
     * @param y y-coordinate
     * @param z z-coordinate
     * @param a a-coordinate
     * @return a random long generated by the seed and the coordinates. Same seed and same coordinates will return the same value
     */
    public long coordLong(int x, int y, int z, int a) {
        long s = coordToLong(x, y, z, a) ^ seed;
        return r(s);
    }

    /**
     * Returns a double generated by the seed and the provided coordiantes
     * <p>
     * This is NOT generated by the generator.
     * Providing the same seed (when constructing or using setSeed()) and the same coordinates will return the same value.
     * You can have up to 4 coordinates when generating such an value.
     * <p>
     * This can be used for games where you can have coordinates with content that is seed-dependent.
     * It can also be used for games where you need random values, but want to be able to re-generate the same ones.
     *
     * @param x x-coordinate
     * @param y y-coordinate
     * @param z z-coordinate
     * @param a a-coordinate
     * @return a random double generated by the seed and the coordinates. Same seed and same coordinates will return the same value
     */

    public double coordDouble(int x, int y, int z, int a) {
        long s = coordToLong(x, y, z, a) ^ seed;
        return rd(s);
    }

    /**
     * Returns a long between the min (incl) and max (excl) values generated by the seed and the provided coordiantes
     * <p>
     * This is NOT generated by the generator.
     * Providing the same seed (when constructing or using setSeed()) and the same coordinates will return the same value.
     * You can have up to 4 coordinates when generating such an value.
     * <p>
     * This can be used for games where you can have coordinates with content that is seed-dependent.
     * It can also be used for games where you need random values, but want to be able to re-generate the same ones.
     *
     * @param x   x-coordinate
     * @param y   y-coordinate
     * @param z   z-coordinate
     * @param a   a-coordinate
     * @param min the minimum value the method can return
     * @param max the upper bound, the returned value cannot become this value
     * @return a random long between min (incl) and max (excl) generated by the seed and the coordinates. Same seed and same values (coords/min/max) will return the same value
     */

    public long coordBetween(int x, int y, int z, int a, long min, long max) {
        if (min < 0 || max < 0 || max < min)
            throw new IllegalArgumentException("min can't be higher than max, and both min and max must be non-negative");
        long s = coordToLong(x, y, z, a) ^ seed;
        return lbetween(s, min, max);
    }

    private long coordToLong(int x, int y) {
        /*
        xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
        32x + 32y
        x << 32
        add y
         */
        return ((long) x << 32) + y;
    }

    private long coordToLong(int x, int y, int z) {
        /*
        xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
       ^z1z1z1z1z1z1z1z10000000000000000z2z2z2z2z2z2z2z20000000000000000
        s1:
        coordToLong
        s2:
        z1 is the most significant digits of the integer
        z2 is the least significant digits of the integer
        z2: (z << 16)
        z1: (long) (z >> 16) << 48

         */
        long transform = coordToLong(x, y);
        transform = transform ^ (z << 16);
        transform = transform ^ ((long) (z >>> 16) << 48);
        return transform;
    }

    private long coordToLong(int x, int y, int z, int a) {
        /*
        xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
       ^a2a2a2a2a2a2a2a2zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzza1a1a1a1a1a1a1a1
        s1:
        coordToLong
        s2:
        a1 is the most significant digits of the integer
        a2 is the least significant digits of the integer
        z << 16
        a2: (long) a << 48
        a1: a >>> 16

         */
        long t2 = ((long) a << 48) + ((long) a >>> 16) + ((long) z << 16);
        return coordToLong(x, y) ^ t2;
    }

    private long r() {
        Random r = new Random();
        return r.nextLong();
    }

    private long r(long s) {
        Random r = new Random(s);
        return r.nextLong();
    }

    private double rd() {
        Random r = new Random();
        return r.nextDouble();
    }

    private double rd(long s) {
        Random r = new Random(s);
        return r.nextDouble();
    }

    private long lbetween(double d, long max) {
        return (long) (d * max);
    }

    private long lbetween(double d, long min, long max) {
        return (long) (d * (max - min) + min);
    }
}
